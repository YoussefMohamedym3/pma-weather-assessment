=== FOLDER TREE FOR: . ===
Tree is ignoring: .env|__pycache__|.git|*_report.txt
.
├── external_apis.py
├── __init__.py
├── weather_crud.py
├── weather_extraction.py
└── weather_service.py

1 directory, 5 files


=======================


=== FILE CONTENTS ===
Find is ignoring: files named '.env, *_report.txt', dirs named '__pycache__, .git'


--- Content of: ./external_apis.py ---
import copy
from datetime import date, datetime, timedelta, timezone
from typing import Any, Dict, List, Optional

import requests
from fastapi import HTTPException

from ..core.config import settings

# --- Private Helper Function: Network Caller (UNMODIFIED) ---


def _fetch_from_weatherapi(endpoint: str, params: Dict[str, Any]) -> Dict[str, Any]:
    """
    Generic, private helper function to call the WeatherAPI.com endpoints.
    """
    if not settings.WEATHERAPI_API_KEY:
        raise HTTPException(
            status_code=500,
            detail="Server configuration error: WeatherAPI key is missing.",
        )

    params["key"] = settings.WEATHERAPI_API_KEY
    base_url = f"{settings.WEATHERAPI_BASE_URL}/{endpoint}"

    try:
        response = requests.get(base_url, params=params)
        response.raise_for_status()
        data = response.json()

        if "error" in data:
            error_msg = data["error"].get("message", "Unknown API error.")
            status_code = data["error"].get("code", 400)

            # 1006 is "No location found matching parameter 'q'"
            if status_code == 1006:
                raise HTTPException(
                    status_code=404, detail=f"Location not found: {error_msg}"
                )

            raise HTTPException(
                status_code=400, detail=f"Weather API Error: {error_msg}"
            )

        return data

    except requests.exceptions.HTTPError as e:
        detail_msg = (
            f"External weather service error: {e.response.reason} - {e.response.text}"
        )
        raise HTTPException(status_code=e.response.status_code, detail=detail_msg)

    except requests.exceptions.RequestException as e:
        raise HTTPException(
            status_code=503, detail=f"Failed to connect to weather service: {e}"
        )


# --- Public Function: Location Validation (NEW) ---


def validate_location_exists(location: str) -> str:
    """
    Uses the /search.json endpoint to validate a location and handle fuzzy matching.
    Returns the official name of the top-matched location.
    Raises 404 if no location is found.
    """
    params = {"q": location}
    try:
        # The search API returns a LIST of matches, not a single dict
        data = _fetch_from_weatherapi("search.json", params)

        if not isinstance(data, list) or not data:
            raise HTTPException(
                status_code=404,
                detail=f"Location not found or ambiguous: '{location}'.",
            )

        # Success: Return the name of the first (best) match
        return data[0].get("name", location)

    except HTTPException as e:
        # Re-raise 404s with a clearer message
        if e.status_code == 404:
            raise HTTPException(
                status_code=404,
                detail=f"Location not found for query: '{location}'.",
            )
        raise e


# --- Public Function: Data Retrieval Orchestrator (MODIFIED) ---


def get_raw_weather_data_for_range(
    location: str, date_from: date, date_to: date
) -> Dict[str, Any]:
    """
    Fetches raw weather data, handling multi-day historical requests
    by looping over history.json calls.
    """
    today = datetime.now(timezone.utc).date()

    # Check 1: CURRENT/FUTURE FORECAST DATA (EASY PATH: single API call)
    # We now use the validated location name passed to this function.
    if date_from >= today:
        params = {"q": location, "days": 14, "aqi": "yes", "alerts": "yes"}
        raw_data = _fetch_from_weatherapi("forecast.json", params)

    # Check 2: HISTORICAL DATA (HARD PATH: requires looping)
    elif date_from < today:
        min_history_date = date(2010, 1, 1)
        if date_from < min_history_date:
            raise HTTPException(
                status_code=400,
                detail=f"Historical data is only available from {min_history_date.isoformat()}.",
            )

        historical_days = []
        current_date = date_from
        last_day_data = {}  # To store the response for location data

        while current_date <= date_to:
            params = {"q": location, "dt": current_date.isoformat(), "aqi": "yes"}
            day_data = _fetch_from_weatherapi("history.json", params)
            last_day_data = day_data  # Save the last successful fetch

            forecast_day_list = day_data.get("forecast", {}).get("forecastday", [])
            if forecast_day_list:
                historical_days.append(forecast_day_list[0])

            current_date += timedelta(days=1)

        if not last_day_data:
            raise HTTPException(
                status_code=404, detail="No historical data found for range."
            )

        # Stitch results into a consistent structure
        raw_data = {
            "location": last_day_data.get("location", {}),
            "forecast": {"forecastday": historical_days},
        }

    else:
        raise HTTPException(
            status_code=500, detail="Internal server error resolving date range type."
        )

    if not raw_data:
        raise HTTPException(
            status_code=500,
            detail="Failed to retrieve weather data for the specified range.",
        )

    return raw_data
--- End of: ./external_apis.py ---


--- Content of: ./__init__.py ---
--- End of: ./__init__.py ---


--- Content of: ./weather_crud.py ---
# File: backend/app/services/weather_crud.py
"""Database interaction layer for WeatherSearch model (CRUD functions)."""

from typing import List, Optional

from fastapi import HTTPException
from sqlalchemy.orm import Session

from ..db.models.weather import WeatherSearch
from ..schemas.weather import WeatherCreate, WeatherUpdate


# Helper function kept here as it's a pure DB read
def get_search_by_id(db: Session, search_id: int) -> Optional[WeatherSearch]:
    """Retrieves a single weather search record by its ID."""
    return db.query(WeatherSearch).filter(WeatherSearch.id == search_id).first()


# READ operation
def get_all_searches(
    db: Session, skip: int = 0, limit: int = 100
) -> List[WeatherSearch]:
    """Retrieves all weather search records, paginated."""
    return (
        db.query(WeatherSearch)
        .order_by(WeatherSearch.created_at.desc())
        .offset(skip)
        .limit(limit)
        .all()
    )


# DELETE operation
def delete_weather_search(db: Session, search_id: int) -> None:
    """Deletes a weather search record by its ID."""
    db_search = get_search_by_id(db, search_id)
    if db_search is None:
        raise HTTPException(status_code=404, detail="Search record not found.")
    db.delete(db_search)
    db.commit()


# CREATE operation (Just the final DB save, the logic happens in weather_service)
def create_db_record(db: Session, db_search: WeatherSearch) -> WeatherSearch:
    """Saves a new WeatherSearch object to the database."""
    db.add(db_search)
    db.commit()
    db.refresh(db_search)
    return db_search


# UPDATE operation (The final DB save part)
def update_db_record(db: Session, db_search: WeatherSearch) -> WeatherSearch:
    """Commits changes to an existing database record."""
    db.commit()
    db.refresh(db_search)
    return db_search
--- End of: ./weather_crud.py ---


--- Content of: ./weather_extraction.py ---
# File: backend/app/services/weather_extraction.py
"""Data extraction, filtering, and calculation logic for API responses."""
import copy
from datetime import date
from typing import Any, Dict, List

from fastapi import HTTPException


# Helper function kept here as it's a pure calculation
def _extract_summary_data_for_db(raw_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Calculates average/max summary statistics for the *entire* filtered range.
    [Rest of function logic is unchanged]
    """
    # ... [Keep the exact logic from the previous weather_service.py here] ...

    forecast_day_list = raw_data.get("forecast", {}).get("forecastday", [])

    if not forecast_day_list:
        raise HTTPException(
            status_code=404,
            detail="No forecast data available for the specified dates after filtering.",
        )

    total_avg_temp = 0
    total_avg_humidity = 0
    max_wind_kph = -float("inf")

    # Get condition from the first day
    first_day_condition = forecast_day_list[0].get("day", {}).get("condition", {})
    condition_text = first_day_condition.get("text", "N/A")

    for day_data in forecast_day_list:
        day_details = day_data.get("day", {})
        total_avg_temp += day_details.get("avgtemp_c", 0)
        total_avg_humidity += day_details.get("avghumidity", 0)
        max_wind_kph = max(max_wind_kph, day_details.get("maxwind_kph", 0))

    count = len(forecast_day_list)
    return {
        "summary_avg_temp_c": total_avg_temp / count,
        "summary_condition_text": condition_text,
        "summary_avg_humidity": total_avg_humidity / count,
        "summary_max_wind_kph": max_wind_kph,
    }


def _filter_raw_data_to_range(
    raw_data: Dict[str, Any], date_from: date, date_to: date
) -> Dict[str, Any]:
    """
    Filters the forecastday list in the raw JSON to only include days
    within the user's requested range.
    """
    forecast_days = raw_data.get("forecast", {}).get("forecastday", [])
    filtered_days = []

    for day_data in forecast_days:
        try:
            day_date = date.fromisoformat(day_data.get("date"))
            if date_from <= day_date <= date_to:
                filtered_days.append(day_data)
        except (ValueError, TypeError):
            continue

    # 2. Use deepcopy to prevent mutating the original data
    filtered_raw_data = copy.deepcopy(raw_data)

    # 3. Now it's safe to modify the nested dictionary
    filtered_raw_data["forecast"]["forecastday"] = filtered_days

    return filtered_raw_data
--- End of: ./weather_extraction.py ---


--- Content of: ./weather_service.py ---
# File: backend/app/services/weather_service.py
"""Orchestration layer: Flow control, high-level validation, and coordinating CRUD/API calls."""

from datetime import date, datetime, timedelta, timezone
from typing import Any, Dict, List, Optional

from fastapi import HTTPException
from sqlalchemy.orm import Session

from ..db.models.weather import WeatherSearch

# --- Specialized Imports ---
from ..schemas.weather import WeatherCreate, WeatherUpdate
from .external_apis import get_raw_weather_data_for_range, validate_location_exists
from .weather_crud import (
    create_db_record,
    delete_weather_search,
    get_all_searches,
    get_search_by_id,
    update_db_record,
)
from .weather_extraction import _extract_summary_data_for_db, _filter_raw_data_to_range

# --- Validation (Stays here as it's the main entry point check) ---


def _validate_date_range(date_from: date, date_to: date) -> None:
    # [Keep the validation logic exactly as it was]

    if date_from > date_to:
        raise HTTPException(
            status_code=400,
            detail="Validation Error: 'search_date_from' cannot be after 'search_date_to'.",
        )

    today = datetime.now(timezone.utc).date()
    max_forecast_date = today + timedelta(days=13)

    if (date_to - date_from).days > 13:
        raise HTTPException(
            status_code=400,
            detail="Validation Error: Search range cannot exceed 14 days.",
        )

    if date_to > max_forecast_date and date_from >= today:
        raise HTTPException(
            status_code=400,
            detail=f"Validation Error: Forecast cannot extend beyond {max_forecast_date.isoformat()} (14-day API limit).",
        )

    min_history_date = date(2010, 1, 1)
    if date_from < min_history_date:
        raise HTTPException(
            status_code=400,
            detail=f"Validation Error: Historical data is only available from {min_history_date.isoformat()}.",
        )


# --- Orchestrator Functions (The Public API of the Service Layer) ---


def create_weather_search(db: Session, request: WeatherCreate) -> WeatherSearch:
    """
    Orchestrates the creation of a new weather record: Validates, Fetches, Extracts, and Saves.
    """

    _validate_date_range(request.search_date_from, request.search_date_to)

    # 1. Location Validation/Fuzzy Match
    validated_location_name = validate_location_exists(request.location_name)

    # 2. Fetch Raw Data
    raw_api_data = get_raw_weather_data_for_range(
        location=validated_location_name,
        date_from=request.search_date_from,
        date_to=request.search_date_to,
    )

    # 3. Filter and Extract
    filtered_raw_data = _filter_raw_data_to_range(
        raw_api_data, request.search_date_from, request.search_date_to
    )
    summary_data = _extract_summary_data_for_db(filtered_raw_data)

    # 4. Build and Save DB Object
    db_search = WeatherSearch(
        location_name=validated_location_name,
        search_date_from=request.search_date_from,
        search_date_to=request.search_date_to,
        **summary_data,
        raw_forecast_data=filtered_raw_data,
        user_note=None,
        google_maps_url=None,
        youtube_video_ids=None,
    )

    return create_db_record(db, db_search)


def update_weather_search(
    db: Session, search_id: int, update_data: WeatherUpdate
) -> WeatherSearch:
    """
    Updates a weather search record. Triggers a full data refresh if search parameters change.
    """
    db_search = get_search_by_id(db, search_id)
    if db_search is None:
        raise HTTPException(status_code=404, detail="Search record not found.")

    needs_refresh = (
        update_data.location_name
        or update_data.search_date_from
        or update_data.search_date_to
    )

    if needs_refresh:
        # Use new data if provided, else fall back to existing data
        new_location = update_data.location_name or db_search.location_name
        new_date_from = update_data.search_date_from or db_search.search_date_from
        new_date_to = update_data.search_date_to or db_search.search_date_to

        # --- Re-run the full validation and fetch logic ---
        _validate_date_range(new_date_from, new_date_to)
        validated_location_name = validate_location_exists(new_location)
        raw_api_data = get_raw_weather_data_for_range(
            location=validated_location_name,
            date_from=new_date_from,
            date_to=new_date_to,
        )
        filtered_raw_data = _filter_raw_data_to_range(
            raw_api_data, new_date_from, new_date_to
        )
        summary_data = _extract_summary_data_for_db(filtered_raw_data)

        # --- Update all data fields (non-user-note) ---
        db_search.location_name = validated_location_name
        db_search.search_date_from = new_date_from
        db_search.search_date_to = new_date_to
        db_search.raw_forecast_data = filtered_raw_data

        for key, value in summary_data.items():
            setattr(db_search, key, value)

    # Update user_note separately (can be done with or without refresh)
    if update_data.user_note is not None:
        db_search.user_note = update_data.user_note

    return update_db_record(db, db_search)


# --- Public READ/DELETE functions are imported directly from weather_crud ---
# These functions (get_all_searches, delete_weather_search, get_search_by_id)
# are public and exposed by weather_service.py, but their implementation
# resides in weather_crud.py (the DB specialist).

# We must ensure they are properly exported/imported if needed by other modules,
# but for the API endpoint, we will just import them directly from weather_service.py.
--- End of: ./weather_service.py ---
